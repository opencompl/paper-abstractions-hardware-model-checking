@article{grosser2015polyast,
 author = {Grosser, Tobias and Verdoolaege, Sven and Cohen, Albert},
 title = {Polyhedral {AST} Generation Is More Than Scanning Polyhedra},
 journal = {ACM Trans. Program. Lang. Syst.},
 issue_date = {July 2015},
 volume = {37},
 number = {4},
 month = jul,
 year = {2015},
 issn = {0164-0925},
 pages = {12:1--12:50},
 articleno = {12},
 numpages = {50},
 url = {http://doi.acm.org/10.1145/2743016},
 doi = {10.1145/2743016},
 acmid = {2743016},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Polyhedral compilation, Presburger relations, code generation, index set splitting, unrolling},
}

@misc{mlir,
      title={MLIR: A Compiler Infrastructure for the End of Moore's Law}, 
      author={Chris Lattner and Mehdi Amini and Uday Bondhugula and Albert Cohen and Andy Davis and Jacques Pienaar and River Riddle and Tatiana Shpeisman and Nicolas Vasilache and Oleksandr Zinenko},
      year={2020},
      eprint={2002.11054},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@misc{symbiyosys, 
  title={SymbiYosys (sby) -- Front-end for Yosys-based formal verification flows}, 
  url={https://github.com/YosysHQ/sby}, 
  journal={GitHub}, 
  note={Accessed 10th March 2025}
}

@misc{opentitan, 
  title={OpenTitan}, 
  url={https://github.com/lowRISC/opentitan}, 
  journal={GitHub}, 
  note={Accessed 10th March 2025}
}

@InProceedings{1219026,  
  author={Clarke, E. and Kroening, D. and Yorav, K.},  
  booktitle={Proceedings 2003. Design Automation Conference (IEEE Cat. No.03CH37451)},   
  title={Behavioral consistency of C and Verilog programs using bounded model checking},  
  year={2003},  
  volume={},  
  number={},  
  pages={368-371},  
  doi={10.1145/775832.775928}
}

@InProceedings{symbolic_mc,
  author = {Burch, Jerry and Clarke, Edmund and McMillan, Kenneth and Dill, David and Hwang, L.},
  year = {1990},
  month = {01},
  pages = {428-439},
  title = {Symbolic Model Checking: 10\^20 States and Beyond},
  doi = {10.1109/LICS.1990.113767}
}

@InProceedings{smt_instead_of_sat,
  author="Armando, Alessandro
  and Mantovani, Jacopo
  and Platania, Lorenzo",
  editor="Valmari, Antti",
  title="Bounded Model Checking of Software Using SMT Solvers Instead of SAT Solvers",
  booktitle="Model Checking Software",
  year="2006",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="146--162",
  isbn="978-3-540-33103-2",
  url = {https://doi.org/10.1007/11691617_9}
}

@InProceedings{gurfinkel2022program,
  title={Program verification with constrained horn clauses},
  author={Gurfinkel, Arie},
  booktitle={International Conference on Computer Aided Verification},
  pages={19--29},
  year={2022},
  organization={Springer}
}

@article{huang2018instruction,
  title={Instruction-level abstraction (ila) a uniform specification for system-on-chip (soc) verification},
  author={Huang, Bo-Yuan and Zhang, Hongce and Subramanyan, Pramod and Vizel, Yakir and Gupta, Aarti and Malik, Sharad},
  journal={ACM Transactions on Design Automation of Electronic Systems (TODAES)},
  volume={24},
  number={1},
  pages={1--24},
  year={2018},
  publisher={ACM New York, NY, USA}
}

@InProceedings{vinarskii2020using,
  title={Using an SMT Solver for Checking the Completeness of FSM-Based Tests},
  author={Vinarskii, Evgenii and Laputenko, Andrey and Yevtushenko, Nina},
  booktitle={Testing Software and Systems: 32nd IFIP WG 6.1 International Conference, ICTSS 2020, Naples, Italy, December 9--11, 2020, Proceedings 32},
  pages={289--295},
  year={2020},
  organization={Springer}
}

@article{chen2021leveraging,
  title={Leveraging control flow knowledge in SMT solving of program verification},
  author={Chen, Jianhui and He, Fei},
  journal={ACM Transactions on Software Engineering and Methodology (TOSEM)},
  volume={30},
  number={4},
  pages={1--26},
  year={2021},
  publisher={ACM New York, NY, USA},
  url = {https://doi.org/10.1145/3446211}
}

@InProceedings{mattarei2018cosa,
  title={Cosa: Integrated verification for agile hardware design},
  author={Mattarei, Cristian and Mann, Makai and Barrett, Clark and Daly, Ross G and Huff, Dillon and Hanrahan, Pat},
  booktitle={2018 Formal Methods in Computer Aided Design (FMCAD)},
  pages={1--5},
  year={2018},
  organization={IEEE}
}

@InProceedings{laeufer2023simulator,
  title={Simulator independent coverage for RTL hardware languages},
  author={Laeufer, Kevin and Iyer, Vighnesh and Biancolin, David and Bachrach, Jonathan and Nikoli{\'c}, Borivoje and Sen, Koushik},
  booktitle={Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 3},
  pages={606--615},
  year={2023}
}

@misc{circt,
    note = {Accessed 10th March 2025},
    title = {CIRCT},
    url = {https://circt.llvm.org/}
}

@misc{llvm,
    note = {https://llvm.org/, Online},
    title = {LLVM},
    url  = {https://llvm.org/}
}

@techreport{camilleri1986hardware,
  title={Hardware verification using higher-order logic},
  author={Camilleri, Albert and Gordon, Mike and Melham, Tom},
  year={1986},
  institution={University of Cambridge, Computer Laboratory}
}

@article{witharana2022survey,
  title={A survey on assertion-based hardware verification},
  author={Witharana, Hasini and Lyu, Yangdi and Charles, Subodha and Mishra, Prabhat},
  journal={ACM Computing Surveys (CSUR)},
  volume={54},
  number={11s},
  pages={1--33},
  year={2022},
  publisher={ACM New York, NY}
}

@article{gupta1992formal,
  title={Formal hardware verification methods: A survey},
  author={Gupta, Aarti},
  journal={Formal Methods in System Design},
  volume={1},
  pages={151--238},
  year={1992},
  publisher={Springer}
}

@incollection{melham1988abstraction,
  title={Abstraction mechanisms for hardware verification},
  author={Melham, Thomas F},
  booktitle={VLSI Specification, Verification and Synthesis},
  pages={267--291},
  year={1988},
  publisher={Springer}
}

@article{dobis2023chiselverify,
title = {Verification of Chisel Hardware Designs with ChiselVerify},
journal = {Microprocessors and Microsystems},
volume = {96},
pages = {104737},
year = {2023},
issn = {0141-9331},
doi = {https://doi.org/10.1016/j.micpro.2022.104737},
url = {https://www.sciencedirect.com/science/article/pii/S0141933122002666},
author = {Amelia Dobis and Kevin Laeufer and Hans Jakob Damsgaard and Tjark Petersen and Kasper Juul Hesse Rasmussen and Enrico Tolotto and Simon Thye Andersen and Richard Lin and Martin Schoeberl},
keywords = {Digital design, Verification, Chisel, Scala},
abstract = {With the current ever-increasing demand for performance, hardware developers find themselves turning ever-more towards the construction of application-specific accelerators to achieve higher performance and lower energy consumption. In order to meet the ever-shortening time constraints, both hardware development and verification tools need to be improved. Chisel, as a hardware construction language, tackles this problem by speeding up the development of digital designs. However, the Chisel infrastructure lacks tools for verification. This paper improves the efficiency of verification in Chisel by proposing methods to support both formal and dynamic verification of digital designs in Scala. It builds on top of ChiselTest, the official testing framework for Chisel. Our work supports functional coverage, constrained random verification, bus functional models, and transaction-level modeling in a verification library named ChiselVerify, while the formal methods are directly integrated into Chisel3.}
}

@inproceedings{bachrach2012chisel,
author = {Bachrach, Jonathan and Vo, Huy and Richards, Brian and Lee, Yunsup and Waterman, Andrew and Avi\v{z}ienis, Rimas and Wawrzynek, John and Asanovi\'{c}, Krste},
title = {Chisel: constructing hardware in a Scala embedded language},
year = {2012},
isbn = {9781450311991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2228360.2228584},
doi = {10.1145/2228360.2228584},
abstract = {In this paper we introduce Chisel, a new hardware construction language that supports advanced hardware design using highly parameterized generators and layered domain-specific hardware languages. By embedding Chisel in the Scala programming language, we raise the level of hardware design abstraction by providing concepts including object orientation, functional programming, parameterized types, and type inference. Chisel can generate a high-speed C++-based cycle-accurate software simulator, or low-level Verilog designed to map to either FPGAs or to a standard ASIC flow for synthesis. This paper presents Chisel, its embedding in Scala, hardware examples, and results for C++ simulation, Verilog emulation and ASIC synthesis.},
booktitle = {Proceedings of the 49th Annual Design Automation Conference},
pages = {1216–1225},
numpages = {10},
keywords = {CAD},
location = {San Francisco, California},
series = {DAC '12}
}

@InProceedings{niemetz2018btor2,
author="Niemetz, Aina
and Preiner, Mathias
and Wolf, Clifford
and Biere, Armin",
editor="Chockler, Hana
and Weissenbacher, Georg",
title="Btor2 , BtorMC and Boolector 3.0",
booktitle="Computer Aided Verification",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="587--595",
abstract="We describe Btor2, a word-level model checking format for capturing models of hardware and potentially software in a bit-precise manner. This simple, line-based and easy to parse format can be seen as a sorted extension of the word-level format Btor. It uses design principles from the bit-level format Aiger and follows semantics of the Smt-Lib logics of bit-vectors with arrays. This intermediate format can be used in various verification flows and is perfectly suited to establish a word-level model checking competition. It is supported by our new open source model checker BtorMC, which is built on top of version 3.0 of our SMT solver Boolector. We further provide new word-level benchmarks on which these open source tools are evaluated.",
isbn="978-3-319-96145-3"
}


@article{grosser2015polyast,
	title        = {Polyhedral {AST} Generation Is More Than Scanning Polyhedra},
	author       = {Grosser, Tobias and Verdoolaege, Sven and Cohen, Albert},
	year         = 2015,
	month        = jul,
	journal      = {ACM Trans. Program. Lang. Syst.},
	publisher    = {ACM},
	address      = {New York, NY, USA},
	volume       = 37,
	number       = 4,
	pages        = {12:1--12:50},
	doi          = {10.1145/2743016},
	issn         = {0164-0925},
	url          = {http://doi.acm.org/10.1145/2743016},
	issue_date   = {July 2015},
	articleno    = 12,
	numpages     = 50,
	acmid        = 2743016,
	keywords     = {Polyhedral compilation, Presburger relations, code generation, index set splitting, unrolling}
}
@inproceedings{grossman2013cascade,
	title        = {The Role of Cascade, a Cycle-Based Simulation Infrastructure, in Designing the Anton Special-Purpose Supercomputers},
	author       = {Grossman, J. P. and Towles, Brian and Bank, Joseph A. and Shaw, David E.},
	year         = 2013,
	booktitle    = {Proceedings of the 50th Annual Design Automation Conference},
	location     = {Austin, Texas},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	series       = {DAC '13},
	doi          = {10.1145/2463209.2488884},
	isbn         = 9781450320719,
	url          = {https://doi.org/10.1145/2463209.2488884},
	abstract     = {Cascade is a cycle-based C++ simulation infrastructure used in the design and verification of two successive versions of Anton, a specialized machine designed for high-speed molecular dynamics computation. Cascade was engineered to address the size and speed challenges inherent in simulating massively parallel special-purpose machines. It provides a lightweight programming interface, rich debugging support, tight Verilog integration, fast multithreaded execution, and low memory overhead. Here, we describe the core features of Cascade that proved most valuable for our simulation efforts.},
	articleno    = 122,
	numpages     = 9,
	keywords     = {anton, cascade, cycle-based simulation, reflection}
}
@inproceedings{tine2020tango,
	title        = {Tango: an optimizing compiler for Just-In-Time RTL simulation},
	author       = {Tine, Blaise-Pascal and Yalamanchili, Sudhakar and Kim, Hyesoon},
	year         = 2020,
	booktitle    = {2020 Design, Automation \& Test in Europe Conference \& Exhibition (DATE)},
	pages        = {157--162},
	organization = {IEEE}
}
@article{abderehman2021fastsim,
	title        = {Fastsim: A fast simulation framework for high-level synthesis},
	author       = {Abderehman, Mohammed and Patidar, Jayprakash and Oza, Jay and Nigam, Yom and Khader, TM Abdul and Karfa, Chandan},
	year         = 2021,
	journal      = {IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems},
	publisher    = {IEEE},
	volume       = 41,
	number       = 5,
	pages        = {1371--1385}
}
@inproceedings{beamer2020efficiently,
	title        = {Efficiently exploiting low activity factors to accelerate RTL simulation},
	author       = {Beamer, Scott and Donofrio, David},
	year         = 2020,
	booktitle    = {2020 57th ACM/IEEE Design Automation Conference (DAC)},
	pages        = {1--6},
	organization = {IEEE}
}

@online{chiseltest,
	title        = {ChiselTest},
	author       = {{UC Berkeley Architecture Research}},
	url          = {https://github.com/ucb-bar/chiseltest}
}
@online{ghidra,
	title        = {Ghidra},
	author       = {{National Security Agency}},
	url          = {https://github.com/NationalSecurityAgency/ghidra}
}
@online{mojo,
	title        = {Mojo},
	author       = {Modular},
	url          = {https://github.com/modularml/mojo}
}
@online{smv,
	title        = {SMV},
	author       = {{Carnegie Mellon University}},
	url          = {https://www.cs.cmu.edu/~modelcheck/smv.html},
        note         = {https://www.cs.cmu.edu/~modelcheck/smv.html}
}

@article{lattner2020mlir,
	title        = {MLIR: A compiler infrastructure for the end of Moore's law},
	author       = {Lattner, Chris and Amini, Mehdi and Bondhugula, Uday and Cohen, Albert and Davis, Andy and Pienaar, Jacques and Riddle, River and Shpeisman, Tatiana and Vasilache, Nicolas and Zinenko, Oleksandr},
	year         = 2020,
	journal      = {arXiv preprint arXiv:2002.11054}
}
// Not 100% sure what this is citing, is the journal just an artefact of a modified citation?
@article{snyder2007verilator,
  title={Verilator: Fast, free, but for me?},
  author={Snyder, Wilson},
  journal={DVClub Presentation},
  pages={11},
  year={2010}
}
@inproceedings{schuiki2020llhd,
	title        = {LLHD: A multi-level intermediate representation for hardware description languages},
	author       = {Schuiki, Fabian and Kurth, Andreas and Grosser, Tobias and Benini, Luca},
	year         = 2020,
	booktitle    = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
	pages        = {258--271}
}
@article{pandianessent,
	title        = {ESSENT: A High-Performance RTL Simulator},
	author       = {Pandian, Scott Beamer Thomas Nijssen Krishna and Zhang, Kyle}
}
@article{systemc,
	title        = {IEEE Standard for Standard SystemC Language Reference Manual},
	author       = {},
	year         = 2012,
	journal      = {IEEE Std 1666-2011 (Revision of IEEE Std 1666-2005)},
	volume       = {},
	number       = {},
	pages        = {1--638},
	doi          = {10.1109/IEEESTD.2012.6134619}
}
@inproceedings{karandikar-firesim-isca18,
	title        = {{FireSim}: {FPGA}-accelerated Cycle-exact Scale-out System Simulation in the Public Cloud},
	author       = {Karandikar, Sagar and Mao, Howard and Kim, Donggyu and Biancolin, David and Amid, Alon and Lee, Dayeol and Pemberton, Nathan and Amaro, Emmanuel and Schmidt, Colin and Chopra, Aditya and Huang, Qijing and Kovacs, Kyle and Nikolic, Borivoje and Katz, Randy and Bachrach, Jonathan and Asanovi\'{c}, Krste},
	year         = 2018,
	booktitle    = {Proceedings of the 45th Annual International Symposium on Computer Architecture},
	location     = {Los Angeles, California},
	publisher    = {IEEE Press},
	address      = {Piscataway, NJ, USA},
	series       = {ISCA '18},
	pages        = {29--42},
	doi          = {10.1109/ISCA.2018.00014},
	isbn         = {978-1-5386-5984-7},
	url          = {https://doi.org/10.1109/ISCA.2018.00014},
	numpages     = 14,
	acmid        = 3276543,
	keywords     = {computer architecture, computer networks, computer simulation, data centers, distributed computing, field programmable gate arrays, performance analysis, scalability}
}
@article{sisco2023loop,
	title        = {Loop Rerolling for Hardware Decompilation},
	author       = {SISCO, ZACHARY D and BALKIND, JONATHAN and SHERWOOD, TIMOTHY and HARDEKOPF, BEN},
	year         = 2023
}
@inproceedings{schoeberl2018lipsi,
	title        = {Lipsi: Probably the smallest processor in the world},
	author       = {Schoeberl, Martin},
	year         = 2018,
	booktitle    = {Architecture of Computing Systems--ARCS 2018: 31st International Conference, Braunschweig, Germany, April 9--12, 2018, Proceedings 31},
	pages        = {18--30},
	organization = {Springer}
}
@article{halbwachs1991synchronous,
	title        = {The synchronous data flow programming language LUSTRE},
	author       = {Halbwachs, Nicholas and Caspi, Paul and Raymond, Pascal and Pilaud, Daniel},
	year         = 1991,
	journal      = {Proceedings of the IEEE},
	publisher    = {IEEE},
	volume       = 79,
	number       = 9,
	pages        = {1305--1320}
}
@article{berry1992esterel,
	title        = {The Esterel synchronous programming language: Design, semantics, implementation},
	author       = {Berry, G{\'e}rard and Gonthier, Georges},
	year         = 1992,
	journal      = {Science of computer programming},
	publisher    = {Elsevier},
	volume       = 19,
	number       = 2,
	pages        = {87--152}
}
@article{benveniste1991synchronous,
	title        = {Synchronous programming with events and relations: the SIGNAL language and its semantics},
	author       = {Benveniste, Albert and Le Guernic, Paul and Jacquemot, Christian},
	year         = 1991,
	journal      = {Science of computer programming},
	publisher    = {Elsevier},
	volume       = 16,
	number       = 2,
	pages        = {103--149}
}
@article{zhaosonicboom,
	title        = {SonicBOOM: The 3rd Generation Berkeley Out-of-Order Machine},
	author       = {Zhao, Jerry and Korpan, Ben and Gonzalez, Abraham and Asanovic, Krste},
	year         = 2020,
	month        = {May},
	booktitle    = {Fourth Workshop on Computer Architecture Research with RISC-V}
}
@article{asanovic2016rocket,
	title        = {The rocket chip generator},
	author       = {Asanovic, Krste and Avizienis, Rimas and Bachrach, Jonathan and Beamer, Scott and Biancolin, David and Celio, Christopher and Cook, Henry and Dabbelt, Daniel and Hauser, John and Izraelevitz, Adam and others},
	year         = 2016,
	journal      = {EECS Department, University of California, Berkeley, Tech. Rep. UCB/EECS-2016-17},
	volume       = 4
}
@misc{zyedidia2022riscinator,
	title        = {Riscinator},
	author       = {Zachary Yedidia},
	year         = 2022,
	journal      = {GitHub repository},
	publisher    = {GitHub},
	howpublished = {\url{https://github.com/zyedidia/riscinator}},
	commit       = {bdf6b82ad26a869f847ad304bf7caa1690d773d1}
}
@inproceedings{chen2018tvm,
	title        = {TVM: An Automated End-to-End Optimizing Compiler for Deep Learning},
	author       = {Chen, Tianqi and Moreau, Thierry and Jiang, Ziheng and Zheng, Lianmin and Yan, Eddie and Cowan, Meghan and Shen, Haichen and Wang, Leyuan and Hu, Yuwei and Ceze, Luis and Guestrin, Carlos and Krishnamurthy, Arvind},
	year         = 2018,
	booktitle    = {Proceedings of the 13th USENIX Conference on Operating Systems Design and Implementation},
	location     = {Carlsbad, CA, USA},
	publisher    = {USENIX Association},
	address      = {USA},
	series       = {OSDI'18},
	pages        = {579–594},
	isbn         = 9781931971478,
	abstract     = {There is an increasing need to bring machine learning to a wide diversity of hardware devices. Current frameworks rely on vendor-specific operator libraries and optimize for a narrow range of server-class GPUs. Deploying workloads to new platforms - such as mobile phones, embedded devices, and accelerators (e.g., FPGAs, ASICs) - requires significant manual effort. We propose TVM, a compiler that exposes graph-level and operator-level optimizations to provide performance portability to deep learning workloads across diverse hardware back-ends. TVM solves optimization challenges specific to deep learning, such as high-level operator fusion, mapping to arbitrary hardware primitives, and memory latency hiding. It also automates optimization of low-level programs to hardware characteristics by employing a novel, learning-based cost modeling method for rapid exploration of code optimizations. Experimental results show that TVM delivers performance across hardware back-ends that are competitive with state-of-the-art, hand-tuned libraries for low-power CPU, mobile GPU, and server-class GPUs. We also demonstrate TVM's ability to target new accelerator back-ends, such as the FPGA-based generic deep learning accelerator. The system is open sourced and in production use inside several major companies.},
	numpages     = 16
}
@inproceedings{urbach2022pytorchHLS,
	title        = {HLS from PyTorch to System Verilog with MLIR and CIRCT},
	author       = {Urbach, Mike and Petersen, Morten B.},
	year         = 2022,
	series       = {LATTE '22}
}
@mastersthesis{ulmann2022thesis,
	title        = {Multi-Level Rewriting for Stream Processing to RTL compilation},
	author       = {Ulmann, Christian},
	year         = 2022,
	pages        = 59,
	institution  = {ETH Zurich},
	school       = {ETH Zurich}
}
@article{li2021MLcompilersurvey,
	title        = {The Deep Learning Compiler: A Comprehensive Survey},
	author       = {Mingzhen Li and Yi Liu and Xiaoyan Liu and Qingxiao Sun and Xin You and Hailong Yang and Zhongzhi Luan and Lin Gan and Guangwen Yang and Depei Qian},
	year         = 2021,
	month        = {mar},
	journal      = {{IEEE} Transactions on Parallel and Distributed Systems},
	publisher    = {Institute of Electrical and Electronics Engineers ({IEEE})},
	volume       = 32,
	number       = 3,
	pages        = {708--727},
	doi          = {10.1109/tpds.2020.3030548},
	url          = {https://doi.org/10.1109%2Ftpds.2020.3030548}
}
@misc{rotem2019glow,
	title        = {Glow: Graph Lowering Compiler Techniques for Neural Networks},
	author       = {Nadav Rotem and Jordan Fix and Saleem Abdulrasool and Garret Catron and Summer Deng and Roman Dzhabarov and Nick Gibson and James Hegeman and Meghan Lele and Roman Levenstein and Jack Montgomery and Bert Maher and Satish Nadathur and Jakob Olesen and Jongsoo Park and Artem Rakhov and Misha Smelyanskiy and Man Wang},
	year         = 2019,
	eprint       = {1805.00907},
	archiveprefix = {arXiv},
	primaryclass = {cs.PL}
}

@report{ucb2016rocket,
	title        = {The Rocket Chip Generator},
	author       = {Asanović, Krste and Avižienis, Rimas and Bachrach, Jonathan and Beamer, Scott and Biancolin, David and Celio, Christopher and Cook, Henry and Dabbelt, Palmer and Hauser, John and Izraelevitz, Adam and Karandikar, Sagar and Keller, Benjamin and Kim, Donggyu and Koenig, John and Lee, Yunsup and Love, Eric and Maas, Martin and Magyar, Albert and Mao, Howard and Moreto, Miquel and Ou, Albert and Patterson, David and Richards, Brian and Schmidt, Colin and Twigg, Stephen and Vo, Huy and Waterman, Andrew},
	year         = 2016,
	month        = {April},
	series       = {Technical Report UCB/EECS-2016-17},
	institution  = {EECS Department, University of California, Berkeley}
}
@INPROCEEDINGS{2017firrtl,
author={A. Izraelevitz and J. Koenig and P. Li and R. Lin and A. Wang and A. Magyar and D. Kim and C. Schmidt and C. Markley and J. Lawson and J. Bachrach},
booktitle={2017 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)},
title={Reusability is FIRRTL ground: Hardware construction languages, compiler frameworks, and transformations},
year={2017},
volume={},
number={},
pages={209-216},
keywords={field programmable gate arrays;hardware description languages;program compilers;software reusability;hardware development practices;hardware libraries;open-source hardware intermediate representation;hardware compiler transformations;Hardware construction languages;retargetable compilers;software development;virtual Cambrian explosion;hardware compiler frameworks;parameterized libraries;FIRRTL;FPGA mappings;Chisel;Flexible Intermediate Representation for RTL;Reusability;Hardware;Libraries;Hardware design languages;Field programmable gate arrays;Tools;Open source software;RTL;Design;FPGA;ASIC;Hardware;Modeling;Reusability;Hardware Design Language;Hardware Construction Language;Intermediate Representation;Compiler;Transformations;Chisel;FIRRTL},
doi={10.1109/ICCAD.2017.8203780},
ISSN={1558-2434},
month={Nov},}

@techreport{li2016firrtl,
    Author = {Li, Patrick S. and Izraelevitz, Adam M. and Bachrach, Jonathan},
    Title = {Specification for the FIRRTL Language},
    Institution = {EECS Department, University of California, Berkeley},
    Year = {2016},
    Month = {Feb},
    URL = {http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-9.html},
    Number = {UCB/EECS-2016-9}
}

@mastersthesis{nijssen2021dedup,
  author  = "Nijssen, Thomas J.",
  title   = "Deduplicating repeated logic to accelerate simulation",
  school  = "University of California, Santa Cruz",
  year    = "2021"
}

@inproceedings{yosys,
  title={Yosys-A Free Verilog Synthesis Suite},
  author={Clifford Wolf and Johann Glaser and Johannes Kepler},
  year={2013},
  url={https://api.semanticscholar.org/CorpusID:202611483}
}

@InProceedings{mlir_circt,
author={Eldridge, Schuyler and Barua, Prithayan and Chapyzhenka, Aliaksei and Izraelevitz, Adam and Koenig, Jack and Lattner, Chris and Lenharth, Andrew and Leontiev, George and Schuiki, Fabian and Sunder, Ram and Young, Andrew and Xia, Richard},
title={{MLIR as Hardware Compiler Infrastructure}},
booktitle={WOSET '21: Workshop on Open Source EDA Technology},
year={2021},
organization={SiFive},
url={https://woset-workshop.github.io/PDFs/2021/a06.pdf}
}


@inproceedings{hunt2006sat,
  title={A SAT-based procedure for verifying finite state machines in ACL2},
  author={Hunt Jr, Warren A and Reeber, Erik},
  booktitle={Proceedings of the sixth international workshop on the ACL2 theorem prover and its applications},
  pages={127--135},
  year={2006}
}

@article{hunt2017industrial,
  title={Industrial hardware and software verification with ACL2},
  author={Hunt Jr, Warren A and Kaufmann, Matt and Moore, J Strother and Slobodova, Anna},
  journal={Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences},
  volume={375},
  number={2104},
  pages={20150399},
  year={2017},
  publisher={The Royal Society Publishing}
}

@inproceedings{btor2,
  title={Btor2 , BtorMC and Boolector 3.0},
  author={Aina Niemetz and Mathias Preiner and Clifford Wolf and Armin Biere},
  booktitle={International Conference on Computer Aided Verification},
  year={2018},
  url={https://api.semanticscholar.org/CorpusID:51868414}
}

@techreport{aiger2,
  author = {Armin Biere and Keijo Heljanko and Siert Wieringa},
  title = {{AIGER 1.9} And Beyond},
  number = {11/2},
  date = {July 2011},
  institution = {Institute for Formal Models and Verification,
    Johannes Kepler University},
  address = {Altenbergerstr. 69, 4040 Linz, Austria},
  year={2011},
  url = {https://fmv.jku.at/papers/BiereHeljankoWieringa-FMV-TR-11-2.pdf}
}

@inbook{avr,
author = {Goel, Aman and Sakallah, Karem},
year = {2020},
month = {04},
pages = {413-422},
title = {AVR: Abstractly Verifying Reachability},
isbn = {978-3-030-45189-9},
doi = {10.1007/978-3-030-45190-5_23}
}

@inproceedings{kaufmann1996acl2,
  title={ACL2: An industrial strength version of Nqthm},
  author={Kaufmann, Matt and Moore, J Strother},
  booktitle={Proceedings of 11th Annual Conference on Computer Assurance. COMPASS'96},
  pages={23--34},
  year={1996},
  organization={IEEE}
}


@misc{fsm_dialect, title={CIRCT FSM Dialect Rationale}, url={https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/}, journal={CIRCT Documentation}, note={Accessed 27/9/23}}

@INPROCEEDINGS{xilinx_hls,
  author={O'Loughlin, Declan and Coffey, Aedan and Callaly, Frank and Lyons, Darren and Morgan, Fearghal},
  booktitle={25th IET Irish Signals \& Systems Conference 2014 and 2014 China-Ireland International Conference on Information and Communications Technologies (ISSC 2014/CIICT 2014)}, 
  title={Xilinx Vivado High Level Synthesis: Case studies}, 
  year={2014},
  volume={},
  number={},
  pages={352-356},
  doi={10.1049/cp.2014.0713}}

@inproceedings{hlhdl,
author = {Zagieboylo, Drew and Sherk, Charles and Suh, Gookwon Edward and Myers, Andrew C.},
title = {PDL: A High-Level Hardware Design Language for Pipelined Processors},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523455},
doi = {10.1145/3519939.3523455},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {719–732},
numpages = {14},
keywords = {Language design, Computer architecture},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

@misc{dragos_poster, title={Google Summer of Code Poster}, url={https://github.com/frog-in-the-well/GSoC-2022-Final-report/blob/main/assets/circt-lec%20poster.pdf
}, howpublished = "\url{https://github.com/frog-in-the-well/GSoC-2022-Final-report/blob/main/assets/circt-lec%20poster.pdf}", note={Accessed 27/9/23}, author = {Dragoș Cristan Lizan}}

@Inbook{Clarke2012,
author="Clarke, Edmund M.
and Klieber, William
and Nov{\'a}{\v{c}}ek, Milo{\v{s}}
and Zuliani, Paolo",
editor="Meyer, Bertrand
and Nordio, Martin",
title="Model Checking and the State Explosion Problem",
bookTitle="Tools for Practical Software Verification: LASER, International Summer School 2011, Elba Island, Italy, Revised Tutorial Lectures",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--30",
abstract="Model checking is an automatic verification technique for hardware and software systems that are finite state or have finite state abstractions. It has been used successfully to verify computer hardware, and it is beginning to be used to verify computer software as well. As the number of state variables in the system increases, the size of the system state space grows exponentially. This is called the ``state explosion problem''. Much of the research in model checking over the past 30 years has involved developing techniques for dealing with this problem. In these lecture notes, we will explain how the basic model checking algorithms work and describe some recent approaches to the state explosion problem, with an emphasis on Bounded Model Checking.",
isbn="978-3-642-35746-6",
doi="10.1007/978-3-642-35746-6_1",
url="https://doi.org/10.1007/978-3-642-35746-6_1"
}

@Inbook{Clarke2001,
author="Clarke, Edmund and Grumberg, Orna and Jha, Somesh and Lu, Yuan and Veith, Helmut",
title="Progress on the State Explosion Problem in Model Checking",
bookTitle="Informatics: 10 Years Back, 10 Years Ahead",
year="2001",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="176--194",
doi="10.1007/3-540-44577-3_12",
url="https://doi.org/10.1007/3-540-44577-3_12"
}

@ARTICLE{SVA,
  author={},
  journal={IEEE Std 1800-2017 (Revision of IEEE Std 1800-2012)}, 
  title={IEEE Standard for SystemVerilog--Unified Hardware Design, Specification, and Verification Language}, 
  year={2018},
  volume={},
  number={},
  pages={364-484},
  doi={10.1109/IEEESTD.2018.8299595}}

@INPROCEEDINGS{flexbex,
  author={Dao, Nguyen and Attwood, Andrew and Healy, Bea and Koch, Dirk},
  booktitle={2020 International Conference on Field-Programmable Technology (ICFPT)}, 
  title={FlexBex: A RISC-V with a Reconfigurable Instruction Extension}, 
  year={2020},
  volume={},
  number={},
  pages={190-195},
  doi={10.1109/ICFPT51103.2020.00034}}

@article{hierarchical_model_checking,
author = {Alur, Rajeev and Yannakakis, Mihalis},
title = {Model Checking of Hierarchical State Machines},
year = {2001},
issue_date = {May 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/503502.503503},
doi = {10.1145/503502.503503},
abstract = {Model checking is emerging as a practical tool for detecting logical errors in early stages of system design. We investigate the model checking of sequential hierarchical (nested) systems, i.e., finite-state machines whose states themselves can be other machines. This nesting ability is common in various software design methodologies, and is available in several commercial modeling tools. The straightforward way to analyze a hierarchical machine is to flatten it (thus incurring an exponential blow up) and apply a model-checking tool on the resulting ordinary FSM. We show that this flattening can be avoided. We develop algorithms for verifying linear-time requirements whose complexity is polynomial in the size of the hierarchical machine. We also address the verification of branching time requirements and provide efficient algorithms and matching lower bounds.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {may},
pages = {273–303},
numpages = {31},
keywords = {statecharts, Hierarchical state machines, temporal logic, model checking}
}

@incollection{buchi,
title = {Symposium on Decision Problems: On a Decision Method in Restricted Second Order Arithmetic},
editor = {Ernest Nagel and Patrick Suppes and Alfred Tarski},
series = {Studies in Logic and the Foundations of Mathematics},
publisher = {Elsevier},
volume = {44},
pages = {1-11},
year = {1966},
booktitle = {Logic, Methodology and Philosophy of Science},
issn = {0049-237X},
doi = {https://doi.org/10.1016/S0049-237X(09)70564-6},
url = {https://www.sciencedirect.com/science/article/pii/S0049237X09705646},
author = {J. {Richard Büchi}},
abstract = {Publisher Summary
In this chapter, SC is a fraction of the restricted second order theory of natural numbers or of the first order theory of real numbers. This chapter discusses the definability in SC and outlines an effective method for deciding the truth of sentences in SC. A congruence of finite rank on words is in congruence with the finite partition of concatenation; a multi-periodic set of words is a union of congruence classes of a congruence of finite rank. These concepts are related to that of a finite automaton and turn out to be the key to an investigation of SC. The results concerning SC may be viewed as an application of the theory of finite automata to logic. In turn, SC arises quite naturally as a condition-language on finite automata or sequential circuits and “sequential calculus” is an appropriate name for SC. The significance of the decision method for SC is that it provides a method for deciding whether or not the input (i)-to-output (u) transformation of a proposed circuit A (i, r, u) satisfies a condition C (i, u) stated in SC.}
}

@article{buchi2,
title = {The complementation problem for Büchi automata with applications to temporal logic},
journal = {Theoretical Computer Science},
volume = {49},
number = {2},
pages = {217-237},
year = {1987},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(87)90008-9},
url = {https://www.sciencedirect.com/science/article/pii/0304397587900089},
author = {A. {Prasad Sistla} and Moshe Y. Vardi and Pierre Wolper},
abstract = {The problem of complementing Büchi automata arises when developing decision procedures for temporal logics of programs. Unfortunately, previously known constructions for complementing Büchi automata involve a doubly exponential blow-up in the size of the automaton. We present a construction that involves only an exponential blow-up. We use this construction to prove a polynomial space upper bound for the propositional temporal logic of regular events and to prove a complexity hierarchy result for quantified propositional temporal logic.}
}

@INPROCEEDINGS{firesim,
  author={Karandikar, Sagar and Mao, Howard and Kim, Donggyu and Biancolin, David and Amid, Alon and Lee, Dayeol and Pemberton, Nathan and Amaro, Emmanuel and Schmidt, Colin and Chopra, Aditya and Huang, Qijing and Kovacs, Kyle and Nikolic, Borivoje and Katz, Randy and Bachrach, Jonathan and Asanovic, Krste},
  booktitle={2018 ACM/IEEE 45th Annual International Symposium on Computer Architecture (ISCA)}, 
  title={FireSim: FPGA-Accelerated Cycle-Exact Scale-Out System Simulation in the Public Cloud}, 
  year={2018},
  volume={},
  number={},
  pages={29-42},
  doi={10.1109/ISCA.2018.00014}}

@inproceedings{z3,
author = {De Moura, Leonardo and Bj\o{}rner, Nikolaj},
title = {Z3: An Efficient SMT Solver},
year = {2008},
isbn = {3540787992},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
booktitle = {Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
pages = {337–340},
numpages = {4},
location = {Budapest, Hungary},
series = {TACAS'08/ETAPS'08},
url = {https://doi.org/10.1007/978-3-540-78800-3_24}
}

@inproceedings{dahlia,
author = {Nigam, Rachit and Atapattu, Sachille and Thomas, Samuel and Li, Zhijing and Bauer, Theodore and Ye, Yuwei and Koti, Apurva and Sampson, Adrian and Zhang, Zhiru},
title = {Predictable accelerator design with time-sensitive affine types},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3385974},
doi = {10.1145/3385412.3385974},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {393–407},
numpages = {15},
keywords = {High-Level Synthesis, Affine Type Systems},
location = {London, UK},
series = {PLDI 2020}
}

@inproceedings{calyx,
author = {Nigam, Rachit and Thomas, Samuel and Li, Zhijing and Sampson, Adrian},
title = {A compiler infrastructure for accelerator generators},
year = {2021},
isbn = {9781450383172},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3445814.3446712},
doi = {10.1145/3445814.3446712},
booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {804–817},
numpages = {14},
keywords = {Accelerator Design, Intermediate Language},
location = {Virtual, USA},
series = {ASPLOS '21}
}

@inproceedings{heterohalide,
author = {Li, Jiajie and Chi, Yuze and Cong, Jason},
title = {HeteroHalide: From Image Processing DSL to Efficient FPGA Acceleration},
year = {2020},
isbn = {9781450370998},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3373087.3375320},
doi = {10.1145/3373087.3375320},
booktitle = {Proceedings of the 2020 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays},
pages = {51–57},
numpages = {7},
keywords = {image processing, high level synthesis, fpgas, domain-specific languages},
location = {Seaside, CA, USA},
series = {FPGA '20}
}


@article{halide_hls,
author = {Pu, Jing and Bell, Steven and Yang, Xuan and Setter, Jeff and Richardson, Stephen and Ragan-Kelley, Jonathan and Horowitz, Mark},
title = {Programming Heterogeneous Systems from an Image Processing DSL},
year = {2017},
issue_date = {September 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {3},
issn = {1544-3566},
url = {https://doi.org/10.1145/3107953},
doi = {10.1145/3107953},
month = {aug},
articleno = {26},
numpages = {25},
keywords = {FPGAs, Image processing, domain specific languages, high-level synthesis}
}

@article{zhang2024optimizing,
      title={An Optimizing Framework on MLIR for Efficient FPGA-based Accelerator Generation}, 
      author={Weichuang Zhang and Jieru Zhao and Guan Shen and Quan Chen and Chen Chen and Minyi Guo},
      year={2024},
      eprint={2401.05154},
      archivePrefix={arXiv},
      primaryClass={cs.AR}
}

@INPROCEEDINGS{chiselverify,
  author={Dobis, Amelia and Petersen, Tjark and Damsgaard, Hans Jakob and Hesse Rasmussen, Kasper Juul and Tolotto, Enrico and Andersen, Simon Thye and Lin, Richard and Schoeberl, Martin},
  booktitle={2021 IEEE Nordic Circuits and Systems Conference (NorCAS)}, 
  title={ChiselVerify: An Open-Source Hardware Verification Library for Chisel and Scala}, 
  year={2021},
  volume={},
  number={},
  pages={1-7},
  keywords={Productivity;Program processors;Ecosystems;Tools;Syntactics;Market research;Hardware;digital design;verification;Chisel;Scala},
  doi={10.1109/NorCAS53631.2021.9599869}}



@InProceedings{model_checking_foundation1,
author="Clarke, E. M.
and Browne, M. C.
and Emerson, E. A.
and Sistla, A. P.",
editor="Apt, Krzysztof R.",
title="Using Temporal Logic for Automatic Verification of Finite State Systems",
booktitle="Logics and Models of Concurrent Systems",
year="1985",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="3--26",
abstract="Temporal logic has been extensively investigated for proving properties of programs-particularly for programs that involve nondeterminism or concurrency ([9], [11], [12]). However, most of the verification techniques developed so far involve manual construction of proofs, a task that may require a good deal of ingenuity and is usually quite tedious. In a series of papers ([1], [5], [6], [10]) we have argued that proof construction is unnecessary in the case of finite state systems and can be replaced by a model theoretic approach which will mechanically determine if the system meets a specification expressed in a propositional temporal logic. In this paper we survey that work and give a detailed example of how our approach might be used in verifying a finite state hardware controller.",
isbn="978-3-642-82453-1"
}

@inproceedings{model_checking_foundation0,
author = {Clarke, Edmund M. and Emerson, E. Allen},
title = {Design and Synthesis of Synchronization Skeletons Using Branching-Time Temporal Logic},
year = {1981},
isbn = {354011212X},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Logic of Programs, Workshop},
pages = {52–71},
numpages = {20},
url = {https://doi.org/10.1007/BFb0025774}
}

@ARTICLE{BDD,
  author={Bryant},
  journal={IEEE Transactions on Computers}, 
  title={Graph-Based Algorithms for Boolean Function Manipulation}, 
  year={1986},
  volume={C-35},
  number={8},
  pages={677-691},
  keywords={Boolean functions;binary decision diagrams;logic design verification;symbolic manipulation},
  doi={10.1109/TC.1986.1676819}}

@INPROCEEDINGS{ctov_tv,
  author={Leung, Alan and Bounov, Dimitar and Lerner, Sorin},
  booktitle={2015 ACM/IEEE International Conference on Formal Methods and Models for Codesign (MEMOCODE)}, 
  title={C-to-Verilog translation validation}, 
  year={2015},
  volume={},
  number={},
  pages={42-47},
  keywords={Hardware design languages;Hardware;Semantics;Syntactics;Program processors;Protocols;Ports (Computers)},
  doi={10.1109/MEMCOD.2015.7340466}}

@INPROCEEDINGS{c_v_consistency,
  author={Kroening, D. and Clarke, E.},
  booktitle={IEEE/ACM International Conference on Computer Aided Design, 2004. ICCAD-2004.}, 
  title={Checking consistency of C and Verilog using predicate abstraction and induction}, 
  year={2004},
  volume={},
  number={},
  pages={66-72},
  keywords={Hardware design languages;Circuit simulation;Circuit testing;Computational modeling;Performance evaluation;Computer simulation;Out of order;Reduced instruction set computing;Buildings;Time to market},
  doi={10.1109/ICCAD.2004.1382544}}

@misc{fpu_lec,
      title={Equivalence Checking a Floating-point Unit against a High-level C Model (Extended Version)}, 
      author={Rajdeep Mukherjee and Saurabh Joshi and Andreas Griesmayer and Daniel Kroening and Tom Melham},
      year={2016},
      eprint={1609.00169},
      archivePrefix={arXiv},
      primaryClass={cs.SE}
}

@INPROCEEDINGS{tp_lec,
  author={Mukherjee, Rajdeep and Kroening, Daniel and Melham, Tom and Srivas, Mandayam},
  booktitle={2015 IEEE Computer Society Annual Symposium on VLSI}, 
  title={Equivalence Checking Using Trace Partitioning}, 
  year={2015},
  volume={},
  number={},
  pages={13-18},
  keywords={Hardware;IP networks;Integrated circuit modeling;Hardware design languages;Universal Serial Bus;Benchmark testing;Software;Equivalence Checking;ANSI-C;Verilog RTL;Trace partitioning;SAT/SMT;Transaction/Scenario;HW/SW co-verification;Symbolic Simulation;Bounded Model Checking},
  doi={10.1109/ISVLSI.2015.110}}

@inproceedings{lec_speedup,
author = {Mishchenko, Alan and Chatterjee, Satrajit and Brayton, Robert and Een, Niklas},
title = {Improvements to combinational equivalence checking},
year = {2006},
isbn = {1595933891},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1233501.1233679},
doi = {10.1145/1233501.1233679},
abstract = {The paper explores several ways to improve the speed and capacity of combinational equivalence checking based on Boolean satisfiability (SAT). State-of-the-art methods use simulation and BDD/SAT sweeping on the input side (i.e. proving equivalence of some internal nodes in a topological order), interleaved with attempts to run SAT on the output (i.e. proving equivalence of the output to constant 0). This paper improves on this method by (a) using more intelligent simulation, (b) using CNF-based SAT with circuit-based decision heuristics, and (c) interleaving SAT with low-effort logic synthesis. Experimental results on public and industrial benchmarks demonstrate substantial reductions in runtime, compared to the current methods. In several cases, the new solver succeeded in solving previously unsolved problems.},
booktitle = {Proceedings of the 2006 IEEE/ACM International Conference on Computer-Aided Design},
pages = {836–843},
numpages = {8},
location = {San Jose, California},
series = {ICCAD '06}
}

@INPROCEEDINGS{deeq,
  author={Abderehman, Mohammed and Rakesh Reddy, Theegala and Karfa, Chandan},
  booktitle={2022 23rd International Symposium on Quality Electronic Design (ISQED)}, 
  title={DEEQ: Data-driven End-to-End EQuivalence Checking of High-level Synthesis}, 
  year={2022},
  volume={},
  number={},
  pages={64-70},
  keywords={Electric potential;Codes;Scalability;Semantics;Merging;Benchmark testing;Registers;High-level Synthesis;RTL;FSMD;C to RTL Equivalence Checking;SMT Solver},
  doi={10.1109/ISQED54688.2022.9806218}}

@inproceedings{k-induction,
  title={Checking Safety Properties Using Induction and a SAT-Solver},
  author={Mary Sheeran and Satnam Singh and Gunnar St{\aa}lmarck},
  booktitle={Formal Methods in Computer-Aided Design},
  year={2000},
  url={https://api.semanticscholar.org/CorpusID:14392278}
}

@InProceedings{bmc_found_1,
author="Biere, Armin
and Cimatti, Alessandro
and Clarke, Edmund
and Zhu, Yunshan",
editor="Cleaveland, W. Rance",
title="Symbolic Model Checking without BDDs",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="1999",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="193--207",
abstract="Symbolic Model Checking [3], [14] has proven to be a powerful technique for the verification of reactive systems. BDDs [2] have traditionally been used as a symbolic representation of the system. In this paper we show how boolean decision procedures, like St{\aa}lmarck's Method [16] or the Davis {\&} Putnam Procedure [7], can replace BDDs. This new technique avoids the space blow up of BDDs, generates counterexamples much faster, and sometimes speeds up the verification. In addition, it produces counterexamples of minimal length. We introduce a bounded model checking procedure for LTL which reduces model checking to propositional satisfiability.We show that bounded LTL model checking can be done without a tableau construction. We have implemented a model checker BMC, based on bounded model checking, and preliminary results are presented.",
isbn="978-3-540-49059-3",
url={https://doi.org/10.1007/3-540-49059-0_14}
}

@ARTICLE{lec_found,
  author={Kuehlmann, A. and Paruthi, V. and Krohm, F. and Ganai, M.K.},
  journal={IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, 
  title={Robust Boolean reasoning for equivalence checking and functional property verification}, 
  year={2002},
  volume={21},
  number={12},
  pages={1377-1394},
  keywords={Robustness;Boolean functions;Data structures;Design automation;Application software;Logic design;Logic circuits;Circuit synthesis;Logic testing;Circuit testing},
  doi={10.1109/TCAD.2002.804386}}

@INPROCEEDINGS{lec_found1,
  author={Kuehlmann, A. and Krohm, F.},
  booktitle={Proceedings of the 34th Design Automation Conference}, 
  title={Equivalence Checking Using Cuts And Heaps}, 
  year={1997},
  volume={},
  number={},
  pages={263-268},
  keywords={Boolean functions;Data structures;Circuits;Binary decision diagrams;Permission;Design methodology;Automatic control;Algorithm design and analysis;Encoding;Automatic test pattern generation},
  doi={10.1109/DAC.1997.597155}}

@INPROCEEDINGS{ic3-kinduction-combo,
  author={Gurfinkel, Arie and Ivrii, Alexander},
  booktitle={2017 Formal Methods in Computer Aided Design (FMCAD)}, 
  title={K-induction without unrolling}, 
  year={2017},
  volume={},
  number={},
  pages={148-155},
  keywords={Model checking;Safety;Optimization;Software algorithms;Hardware;Software;Cognition},
  doi={10.23919/FMCAD.2017.8102253}}

@InProceedings{ic3,
author="Bradley, Aaron R.",
editor="Jhala, Ranjit
and Schmidt, David",
title="SAT-Based Model Checking without Unrolling",
booktitle="Verification, Model Checking, and Abstract Interpretation",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="70--87",
abstract="A new form of SAT-based symbolic model checking is described. Instead of unrolling the transition relation, it incrementally generates clauses that are inductive relative to (and augment) stepwise approximate reachability information. In this way, the algorithm gradually refines the property, eventually producing either an inductive strengthening of the property or a counterexample trace. Our experimental studies show that induction is a powerful tool for generalizing the unreachability of given error states: it can refine away many states at once, and it is effective at focusing the proof search on aspects of the transition system relevant to the property. Furthermore, the incremental structure of the algorithm lends itself to a parallel implementation.",
isbn="978-3-642-18275-4",
url="https://doi.org/10.1007/978-3-642-18275-4_7"
}

@inproceedings{ic3_original,
author = {Bradley, Aaron and Manna, Zohar},
year = {2007},
month = {12},
pages = {173-180},
title = {Checking Safety by Inductive Generalization of Counterexamples to Induction},
isbn = {978-0-7695-3023-9},
doi = {10.1109/FAMCAD.2007.15}
}

@INPROCEEDINGS{halide_lec,
  author={Wang, Yanzhao and Xie, Fei and Yang, Zhenkun and Cocchini, Pasquale and Yang, Jin},
  booktitle={2023 28th Asia and South Pacific Design Automation Conference (ASP-DAC)}, 
  title={An Equivalence Checking Framework for Agile Hardware Design}, 
  year={2023},
  volume={},
  number={},
  pages={26-32},
  keywords={Deep learning;Design automation;Image processing;Asia;Hardware;Hardware acceleration;Domain specific languages;Equivalence Checking;Halide;Agile Hardware;Formal Verification},
  doi={}}

@inproceedings{smtlib,
  title={The SMT-LIB Standard Version 2.0},
  author={Clark W. Barrett and Aaron Stump and Cesare Tinelli},
  year={2010},
  url={https://api.semanticscholar.org/CorpusID:7943149}
}

@article{chen2024allo,
    author = {Hongzheng Chen and Niansong Zhang and Shaojie Xiang and Zhichen Zeng and Mengjia Dai and Zhiru Zhang},
    title = {Allo: A Programming Model for Composable Accelerator Design},
    journal = {Proc. ACM Program. Lang.},
    year = {2024},
    month = {jun},
    url = {https://doi.org/10.1145/3656401},
    doi = {10.1145/3656401},
    articleno = {171},
    volume = {8},
    number = {PLDI},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    issue_date = {June 2024},
}

@MASTERSTHESIS{amelia_thesis,
	copyright = {In Copyright - Non-Commercial Use Permitted},
	year = {2024},
	type = {Master Thesis},
	author = {Dobis, Amelia},
	size = {80 p.},
	language = {en},
	address = {Zurich},
	publisher = {ETH Zurich},
	DOI = {10.3929/ethz-b-000668906},
	title = {Formal Verification of Hardware using MLIR},
	school = {ETH Zurich}
}

@misc{zhao2024kcirct,
      title={K-CIRCT: A Layered, Composable, and Executable Formal Semantics for CIRCT Hardware IRs}, 
      author={Jianhong Zhao and Jinhui Kang and Yongwang Zhao},
      year={2024},
      eprint={2404.18756},
      archivePrefix={arXiv},
      primaryClass={cs.SE}
}

@misc{brauckmann2023mlirsynth,
      title={mlirSynth: Automatic, Retargetable Program Raising in Multi-Level IR using Program Synthesis}, 
      author={Alexander Brauckmann and Elizabeth Polgreen and Tobias Grosser and Michael F. P. O'Boyle},
      year={2023},
      eprint={2310.04196},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@INPROCEEDINGS{slade,
  author={Armengol-Estapé, Jordi and Woodruff, Jackson and Cummins, Chris and O'Boyle, Michael F.P.},
  booktitle={2024 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)}, 
  title={SLaDe: A Portable Small Language Model Decompiler for Optimized Assembly}, 
  year={2024},
  volume={},
  number={},
  pages={67-80},
  doi={10.1109/CGO57630.2024.10444788}}

@inproceedings{nuxmv,
  author    = {Roberto Cavada and
               Alessandro Cimatti and
               Michele Dorigatti and
               Alberto Griggio and
               Alessandro Mariotti and
               Andrea Micheli and
               Sergio Mover and
               Marco Roveri and
               Stefano Tonetta},
  title     = {The nuXmv Symbolic Model Checker},
  booktitle = {CAV},
  year      = {2014},
  pages     = {334-342},
  ee        = {http://dx.doi.org/10.1007/978-3-319-08867-9_22},
  crossref  = {DBLP:conf/cav/2014},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@article{nusmv,
author = {Cimatti, Alessandro and Clarke, Edmund and Giunchiglia, Fausto and Roveri, Marco},
year = {2000},
month = {03},
pages = {410-425},
title = {NUSMV: a new symbolic model checker},
volume = {2},
journal = {STTT},
doi = {10.1007/s100090050046}
}

@article{hw_fv_survey,
author = {Kern, Christoph and Greenstreet, Mark R.},
title = {Formal verification in hardware design: a survey},
year = {1999},
issue_date = {April 1999},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {2},
issn = {1084-4309},
url = {https://doi.org/10.1145/307988.307989},
doi = {10.1145/307988.307989},
abstract = {In recent years, formal methods have emerged as an alternative approach to ensuring the quality and correctness of hardware designs, overcoming some of the limitations of traditional validation techniques such as simulation and testing.There are two main aspects to the application of formal methods in a design process: the formal framework used to specify desired properties of a design and the verification techniques and tools used to reason about the relationship between a specification and a corresponding implementation. We survey a variety of frameworks and techniques proposed in the literature and applied to actual designs. The specification frameworks we describe include temporal logics, predicate logic, abstraction and refinement, as well as containment between  ω-regular languages. The verification techniques presented include model checking, automata-theoretic techniques, automated theorem proving, and approaches that integrate the above methods.In order to provide insight into the scope and limitations of currently available techniques, we present a selection of case studies where formal methods were applied to industrial-scale designs, such as microprocessors, floating-point hardware, protocols, memory subsystems, and communications hardware.},
journal = {ACM Trans. Des. Autom. Electron. Syst.},
month = {apr},
pages = {123–193},
numpages = {71},
keywords = {case studies, formal methods, formal verification, hardware verification, language containment, model checking, survey, theorem proving}
}

@article{gupta_hw_fv_survey,
title = "Formal hardware verification methods: A survey",
abstract = "Growing advances in VLSI technology have led to an increased level of complexity in current hardware systems. Late detection of design errors typically results in higher costs due to the associated time delay as well as loss of production. Thus it is important that hardware designs be free of errors. Formal verification has become an increasingly important technique towards establishing the correctness of hardware designs. In this article we survey the research that has been done in this area, with an emphasis on more recent trends. We present a classification framework for the various methods, based on the forms of the specification, the implementation, and the proff method. This framework enables us to better highlight the relationships and interactions between seemingly different approaches.",
keywords = "design correctness, formal verification, hardware verification, proof methods, specification",
author = "Aarti Gupta",
year = "1992",
month = oct,
doi = "10.1007/BF00121125",
language = "English (US)",
volume = "1",
pages = "151--238",
journal = "Formal Methods in System Design",
issn = "0925-9856",
publisher = "Springer Netherlands",
number = "2-3",
}

@InProceedings{kowalewski2009boolector,
author="Brummayer, Robert
and Biere, Armin",
editor="Kowalewski, Stefan
and Philippou, Anna",
title="Boolector: An Efficient SMT Solver for Bit-Vectors and Arrays",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="174--177",
abstract="Satisfiability Modulo Theories (SMT) is the problem of deciding satisfiability of a logical formula, expressed in a combination of first-order theories. We present the architecture and selected features of Boolector, which is an efficient SMT solver for the quantifier-free theories of bit-vectors and arrays. It uses term rewriting, bit-blasting to handle bit-vectors, and lemmas on demand for arrays.",
isbn="978-3-642-00768-2",
url = {https://doi.org/10.1007/978-3-642-00768-2_16}
}

@misc{niemetz2020bitwuzla,
      title={Bitwuzla at the SMT-COMP 2020}, 
      author={Aina Niemetz and Mathias Preiner},
      year={2020},
      eprint={2006.01621},
      archivePrefix={arXiv},
      primaryClass={cs.LO},
      url={https://arxiv.org/abs/2006.01621}, 
}

@techreport{wilson2020verifstudy,
     title = {{The 2020 Wilson Research Group Functional Verification Study}},
     author = {Harry Foster},
     year = {2020},
     institution = {Siemens},
}

@techreport{wilson2022verifstudy,
     title = {{The 2022 Wilson Research Group Functional Verification Study}},
     author = {Harry Foster},
     year = {2022},
     institution = {Siemens},
}

@techreport{wilson2018verifstudy,
     title = {{The 2018 Wilson Research Group Functional Verification Study}},
     author = {Harry Foster},
     year = {2018},
     institution = {Siemens},
}

@misc{arcilator,
author={Erhart, Martin and Schuiki, Fabian and Yedidia, Zachary and Healy, Bea and Grosser, Tobias},
title={{Arcilator: Fast and cycle-accurate hardware simulation in CIRCT}},
howpublished="\url{https://llvm.org/devmtg/2023-10/slides/techtalks/Erhart-Arcilator-FastAndCycleAccurateHardwareSimulationInCIRCT.pdf}"
}

@inproceedings{daly2018coreir,
  title={Invoking and Linking Generators from Multiple Hardware Languages using CoreIR},
  author={Ross G. Daly and Lenny Truong and Pat Hanrahan},
  year={2018},
  url={https://api.semanticscholar.org/CorpusID:211106577}
}

@ARTICLE{arvind1999trs,
  author={Arvind and Shen, X.},
  journal={IEEE Micro}, 
  title={Using term rewriting systems to design and verify processors}, 
  year={1999},
  volume={19},
  number={3},
  pages={36-46},
  keywords={Process design;Registers;Microarchitecture;Microprocessors;Computer architecture;Reduced instruction set computing;Arithmetic;High level synthesis;Costs;Formal verification},
  doi={10.1109/40.768501}}

  @INPROCEEDINGS{bluespec,
  author={Nikhil, R.},
  booktitle={Proceedings. Second ACM and IEEE International Conference on Formal Methods and Models for Co-Design, 2004. MEMOCODE '04.}, 
  title={Bluespec System Verilog: efficient, correct RTL from high level specifications}, 
  year={2004},
  volume={},
  number={},
  pages={69-70},
  keywords={Hardware;Productivity;High level synthesis;Atomic measurements;Application specific integrated circuits;Field programmable gate arrays;Flow graphs;Scheduling;Logic design;Predictive models},
  doi={10.1109/MEMCOD.2004.1459818}}

@article{bluespec_smt,
author = {Dave, Nirav and Katelman, Michael and King, Myron and Arvind, Arvind},
year = {2011},
month = {07},
pages = {},
title = {Verification of microarchitectural refinements in rule-based systems},
journal = {9th ACM/IEEE International Conference on Formal Methods and Models for Codesign, MEMOCODE 2011},
doi = {10.1109/MEMCOD.2011.5970511}
}

@article{bluespec_itp,
author = {Choi, Joonwon and Vijayaraghavan, Muralidaran and Sherman, Benjamin and Chlipala, Adam and Arvind},
title = {Kami: a platform for high-level parametric hardware specification and its modular verification},
year = {2017},
issue_date = {September 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {ICFP},
url = {https://doi.org/10.1145/3110268},
doi = {10.1145/3110268},
abstract = {It has become fairly standard in the programming-languages research world to verify functional programs in proof assistants using induction, algebraic simplification, and rewriting. In this paper, we introduce Kami, a Coq library that enables similar expressive and modular reasoning for hardware designs expressed in the style of the Bluespec language. We can specify, implement, and verify realistic designs entirely within Coq, ending with automatic extraction into a pipeline that bottoms out in FPGAs. Our methodology, using labeled transition systems, has been evaluated in a case study verifying an infinite family of multicore systems, with cache-coherent shared memory and pipelined cores implementing (the base integer subset of) the RISC-V instruction set.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {24},
numpages = {30},
keywords = {proof assistants, hardware, formal verification}
}

@misc{chctools, 
  title={chctools}, 
  url={https://github.com/chc-comp/chc-tools/}, 
  journal={GitHub}, 
  note={Accessed 10th March 2025}
}

@misc{btor2tools, 
  title={btor2tools}, 
  url={https://github.com/hwmcc/btor2tools/}, 
  journal={GitHub}, 
  note={Accessed 11th March 2025}
}

@book{pedroni2013fsms,
    author = {Pedroni, Volnei A.},
    title = {Finite State Machines in Hardware: Theory and Design (with VHDL and SystemVerilog)},
    publisher = {The MIT Press},
    year = {2013},
    month = {12},
    abstract = {A comprehensive guide to the theory and design of hardware-implemented finite state machines, with design examples developed in both VHDL and SystemVerilog languages.Modern, complex digital systems invariably include hardware-implemented finite state machines. The correct design of such parts is crucial for attaining proper system performance. This book offers detailed, comprehensive coverage of the theory and design for any category of hardware-implemented finite state machines. It describes crucial design problems that lead to incorrect or far from optimal implementation and provides examples of finite state machines developed in both VHDL and SystemVerilog (the successor of Verilog) hardware description languages.Important features include: extensive review of design practices for sequential digital circuits; a new division of all state machines into three hardware-based categories, encompassing all possible situations, with numerous practical examples provided in all three categories; the presentation of complete designs, with detailed VHDL and SystemVerilog codes, comments, and simulation results, all tested in FPGA devices; and exercise examples, all of which can be synthesized, simulated, and physically implemented in FPGA boards. Additional material is available on the book's Website. Designing a state machine in hardware is more complex than designing it in software. Although interest in hardware for finite state machines has grown dramatically in recent years, there is no comprehensive treatment of the subject. This book offers the most detailed coverage of finite state machines available. It will be essential for industrial designers of digital systems and for students of electrical engineering and computer science.},
    isbn = {9780262319096},
    doi = {10.7551/mitpress/9657.001.0001},
    url = {https://doi.org/10.7551/mitpress/9657.001.0001},
}

@book{kaufmann2000acl2,
author = {Kaufmann, Matt and Manolios, Panagiotis and Moore, Jstrother},
year = {2000},
month = {06},
pages = {},
title = {Computer-Aided Reasoning: An Approach},
volume = {3},
isbn = {978-1-4613-7003-1},
doi = {10.1007/978-1-4615-4449-4}
}

@article{herklotz2021vericert,
author = {Herklotz, Yann and Pollard, James D. and Ramanathan, Nadesh and Wickerson, John},
title = {Formal verification of high-level synthesis},
year = {2021},
issue_date = {October 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {OOPSLA},
url = {https://doi.org/10.1145/3485494},
doi = {10.1145/3485494},
abstract = {High-level synthesis (HLS), which refers to the automatic compilation of software into hardware, is rapidly gaining popularity. In a world increasingly reliant on application-specific hardware accelerators, HLS promises hardware designs of comparable performance and energy efficiency to those coded by hand in a hardware description language such as Verilog, while maintaining the convenience and the rich ecosystem of software development. However, current HLS tools cannot always guarantee that the hardware designs they produce are equivalent to the software they were given, thus undermining any reasoning conducted at the software level. Furthermore, there is mounting evidence that existing HLS tools are quite unreliable, sometimes generating wrong hardware or crashing when given valid inputs. To address this problem, we present the first HLS tool that is mechanically verified to preserve the behaviour of its input software. Our tool, called Vericert, extends the CompCert verified C compiler with a new hardware-oriented intermediate language and a Verilog back end, and has been proven correct in Coq. Vericert supports most C constructs, including all integer operations, function calls, local arrays, structs, unions, and general control-flow statements. An evaluation on the PolyBench/C benchmark suite indicates that Vericert generates hardware that is around an order of magnitude slower (only around 2\texttimes{} slower in the absence of division) and about the same size as hardware generated by an existing, optimising (but unverified) HLS tool.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {117},
numpages = {30},
keywords = {high-level synthesis, Verilog, Coq, CompCert, C}
}

@article{leroy2009compcert,
author = {Leroy, Xavier},
title = {Formal verification of a realistic compiler},
year = {2009},
issue_date = {July 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/1538788.1538814},
doi = {10.1145/1538788.1538814},
abstract = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
journal = {Commun. ACM},
month = jul,
pages = {107–115},
numpages = {9}
}

@unknown{metz2024rhls,
author = {Metz, David and Reissmann, Nico and Själander, Magnus},
year = {2024},
month = {08},
pages = {},
title = {R-HLS: An IR for Dynamic High-Level Synthesis and Memory Disambiguation based on Regions and State Edges},
doi = {10.48550/arXiv.2408.08712}
}

@article{barkalov2021fsmdecomp,
author = {Barkalov, Alexander and Titarenko, Larysa and Krzywicki, Kazimierz},
year = {2021},
month = {05},
pages = {1174},
title = {Structural Decomposition in FSM Design: Roots, Evolution, Current State—A Review},
volume = {10},
journal = {Electronics},
doi = {10.3390/electronics10101174}
}

@ARTICLE{barkalov2024fsmreduct,
  author={Barkalov, Alexander and Titarenko, Larysa and Mielcarek, Kamil and Mazurkiewicz, Małgorzata},
  journal={IEEE Access}, 
  title={Hardware Reduction for FSMs With Extended State Codes}, 
  year={2024},
  volume={12},
  number={},
  pages={42369-42384},
  keywords={Codes;Table lookup;Field programmable gate arrays;Power demand;Optimization;Integrated circuit interconnections;Hardware;Logic circuits;Automata;Mealy FSM;FPGA;LUT count;synthesis;extended state codes;composite state codes;mixed state codes},
  doi={10.1109/ACCESS.2024.3376472}}

@INPROCEEDINGS{giomi1995fsmextraction,
  author={Giomi, J.-C.},
  booktitle={Proceedings of Eighth International Application Specific Integrated Circuits Conference}, 
  title={Finite state machine extraction from hardware description languages}, 
  year={1995},
  volume={},
  number={},
  pages={353-357},
  keywords={Automata;Hardware design languages;Flow graphs;Clocks;Logic;Data mining;Computer architecture;Design automation;Performance analysis},
  doi={10.1109/ASIC.1995.580747}}

@INPROCEEDINGS{shi2010fsmextraction,
  author={Shi, Yiqiong and Ting, Chan Wai and Gwee, Bah-Hwee and Ren, Ye},
  booktitle={Proceedings of 2010 IEEE International Symposium on Circuits and Systems}, 
  title={A highly efficient method for extracting FSMs from flattened gate-level netlist}, 
  year={2010},
  volume={},
  number={},
  pages={2610-2613},
  keywords={Registers;Digital circuits;Microcontrollers;Circuit synthesis;Design automation;Logic;Signal processing;Automata;Hardware design languages;Continuous wavelet transforms},
  doi={10.1109/ISCAS.2010.5537093}}

@inproceedings{liu1998fsm,
  title={A FSM extractor for HDL description at RTL level},
  author={Liu, Chien-Nan and Jou, Jing-Yang},
  booktitle={Proc. of Asia-Pacific Conference on Hardware Description Languages},
  pages={33--38},
  year={1998},
  organization={Citeseer}
}

@manual{vivadouserguide,
  title        = {Vivado Design Suite User Guide: Synthesis (UG901)},
  author       = {Xilinx},
  year         = 2024
}

@manual{iseguide,
  title        = {ISE In-Depth Tutorial},
  author       = {Xilinx},
  year         = 2012
}

@misc{majumder2021hir,
      title={HIR: An MLIR-based Intermediate Representation for Hardware Accelerator Description}, 
      author={Kingshuk Majumder and Uday Bondhugula},
      year={2021},
      eprint={2103.00194},
      archivePrefix={arXiv},
      primaryClass={cs.AR},
      url={https://arxiv.org/abs/2103.00194}, 
}

@Inbook{clarke2012explosion,
author="Clarke, Edmund M.
and Klieber, William
and Nov{\'a}{\v{c}}ek, Milo{\v{s}}
and Zuliani, Paolo",
title="Model Checking and the State Explosion Problem",
bookTitle="Tools for Practical Software Verification: LASER, International Summer School 2011, Elba Island, Italy, Revised Tutorial Lectures",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--30",
abstract="Model checking is an automatic verification technique for hardware and software systems that are finite state or have finite state abstractions. It has been used successfully to verify computer hardware, and it is beginning to be used to verify computer software as well. As the number of state variables in the system increases, the size of the system state space grows exponentially. This is called the ``state explosion problem''. Much of the research in model checking over the past 30 years has involved developing techniques for dealing with this problem. In these lecture notes, we will explain how the basic model checking algorithms work and describe some recent approaches to the state explosion problem, with an emphasis on Bounded Model Checking.",
isbn="978-3-642-35746-6",
doi="10.1007/978-3-642-35746-6_1",
url="https://doi.org/10.1007/978-3-642-35746-6_1"
}

@InProceedings{spacer1,
author="Komuravelli, Anvesh
and Gurfinkel, Arie
and Chaki, Sagar",
editor="Biere, Armin
and Bloem, Roderick",
title="SMT-Based Model Checking for Recursive Programs",
booktitle="Computer Aided Verification",
year="2014",
publisher="Springer International Publishing",
address="Cham",
pages="17--34",
abstract="We present an SMT-based symbolic model checking algorithm for safety verification of recursive programs. The algorithm is modular and analyzes procedures individually. Unlike other SMT-based approaches, it maintains both over- and under-approximations of procedure summaries. Under-approximations are used to analyze procedure calls without inlining. Over-approximations are used to block infeasible counterexamples and detect convergence to a proof. We show that for programs and properties over a decidable theory, the algorithm is guaranteed to find a counterexample, if one exists. However, efficiency depends on an oracle for quantifier elimination (QE). For Boolean Programs, the algorithm is a polynomial decision procedure, matching the worst-case bounds of the best BDD-based algorithms. For Linear Arithmetic (integers and rationals), we give an efficient instantiation of the algorithm by applying QE lazily. We use existing interpolation techniques to over-approximate QE and introduce Model Based Projection to under-approximate QE. Empirical evaluation on SV-COMP benchmarks shows that our algorithm improves significantly on the state-of-the-art.",
isbn="978-3-319-08867-9"
}

@inproceedings{spacer2,
author = {Komuravelli, Anvesh and Gurfinkel, Arie and Chaki, Sagar and Clarke, Edmund M.},
title = {Automatic Abstraction in SMT-Based Unbounded Software Model Checking},
year = {2013},
isbn = {9783642397981},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Software model checkers based on under-approximations and SMT solvers are very successful at verifying safety i.e., reachability properties. They combine two key ideas --- a concreteness: a counterexample in an under-approximation is a counterexample in the original program as well, and b generalization: a proof of safety of an under-approximation, produced by an SMT solver, are generalizable to proofs of safety of the original program. In this paper, we present a combination of automatic abstraction with the under-approximation-driven framework. We explore two iterative approaches for obtaining and refining abstractions --- proof based and counterexample based --- and show how they can be combined into a unified algorithm. To the best of our knowledge, this is the first application of Proof-Based Abstraction, primarily used to verify hardware, to Software Verification. We have implemented a prototype of the framework using Z3, and evaluate it on many benchmarks from the Software Verification Competition. We show experimentally that our combination is quite effective on hard instances.},
booktitle = {Proceedings of the 25th International Conference on Computer Aided Verification - Volume 8044},
pages = {846–862},
numpages = {17},
location = {Saint Petersburg, Russia},
series = {CAV 2013}
}

@misc{ric3,
      title={The rIC3 Hardware Model Checker},
      author={Yuheng Su and Qiusong Yang and Yiwei Ci and Tianjun Bu and Ziyu Huang},
      year={2025},
      eprint={2502.13605},
      archivePrefix={arXiv},
      primaryClass={cs.FL},
      url={https://arxiv.org/abs/2502.13605}, 
}

@ARTICLE{spechls,
  author={Gorius, Jean-Michel and Rokicki, Simon and Derrien, Steven},
  journal={IEEE Micro}, 
  title={SpecHLS: Speculative Accelerator Design Using High-Level Synthesis}, 
  year={2022},
  volume={42},
  number={5},
  pages={99-107},
  keywords={Codes;Pipeline processing;Hardware accelerators;Delays;Logic gates;Schedules;Graph theory},
  doi={10.1109/MM.2022.3188136}}

@ARTICLE{nejati2021explosion,
  author={Nejati, Faranak and Ghani, Abdul Azim Abd and Yap, Ng Keng and Jafaar, Azmi Bin},
  journal={IEEE Access}, 
  title={Handling State Space Explosion in Component-Based Software Verification: A Review}, 
  year={2021},
  volume={9},
  number={},
  pages={77526-77544},
  keywords={Computational modeling;Explosions;Atmospheric modeling;Software systems;Search problems;Model checking;Component-based software development;verification of software components;model-checking;state space explosion},
  doi={10.1109/ACCESS.2021.3081742}}

@inproceedings{xu2021mixedsmt,
author = {Xu, Dongpeng and Liu, Binbin and Feng, Weijie and Ming, Jiang and Zheng, Qilong and Li, Jing and Yu, Qiaoyan},
title = {Boosting SMT solver performance on mixed-bitwise-arithmetic expressions},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454068},
doi = {10.1145/3453483.3454068},
abstract = {Satisfiability Modulo Theories (SMT) solvers have been widely applied in automated software analysis to reason about the queries that encode the essence of program semantics, relieving the heavy burden of manual analysis. Many SMT solving techniques rely on solving Boolean satisfiability problem (SAT), which is an NP-complete problem, so they use heuristic search strategies to seek possible solutions, especially when no known theorem can efficiently reduce the problem. An emerging challenge, named Mixed-Bitwise-Arithmetic (MBA) obfuscation, impedes SMT solving by constructing identity equations with both bitwise operations (and, or, negate) and arithmetic computation (add, minus, multiply). Common math theorems for bitwise or arithmetic computation are inapplicable to simplifying MBA equations, leading to performance bottlenecks in SMT solving.  In this paper, we first scrutinize solvers' performance on solving different categories of MBA expressions: linear, polynomial, and non-polynomial. We observe that solvers can handle simple linear MBA expressions, but facing a severe performance slowdown when solving complex linear and non-linear MBA expressions. The root cause is that complex MBA expressions break the reduction laws for pure arithmetic or bitwise computation. To boost solvers' performance, we propose a semantic-preserving transformation to reduce the mixing degree of bitwise and arithmetic operations. We first calculate a signature vector based on the truth table extracted from an MBA expression, which captures the complete MBA semantics. Next, we generate a simpler MBA expression from the signature vector. Our large-scale evaluation on 3000 complex MBA equations shows that our technique significantly boost modern SMT solvers' performance on solving MBA formulas.},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {651–664},
numpages = {14},
keywords = {Simplification, SMT Solvers, Mixed Boolean Arithmetic},
location = {Virtual, Canada},
series = {PLDI 2021}
}

@misc{conti2024pulp,
      title={Open-Source Heterogeneous SoCs for AI: The PULP Platform Experience}, 
      author={Francesco Conti and Angelo Garofalo and Davide Rossi and Giuseppe Tagliavini and Luca Benini},
      year={2024},
      eprint={2412.20391},
      archivePrefix={arXiv},
      primaryClass={cs.AR},
      url={https://arxiv.org/abs/2412.20391}, 
}

@InProceedings{abc,
author="Brayton, Robert
and Mishchenko, Alan",
editor="Touili, Tayssir
and Cook, Byron
and Jackson, Paul",
title="ABC: An Academic Industrial-Strength Verification Tool",
booktitle="Computer Aided Verification",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="24--40",
abstract="ABC is a public-domain system for logic synthesis and formal verification of binary logic circuits appearing in synchronous hardware designs. ABC combines scalable logic transformations based on And-Inverter Graphs (AIGs), with a variety of innovative algorithms. A focus on the synergy of sequential synthesis and sequential verification leads to improvements in both domains. This paper introduces ABC, motivates its development, and illustrates its use in formal verification.",
isbn="978-3-642-14295-6",
url={https://doi.org/10.1007/978-3-642-14295-6_5}
}

@Inbook{bjorner2015horn,
author="Bj{\o}rner, Nikolaj
and Gurfinkel, Arie
and McMillan, Ken
and Rybalchenko, Andrey",
editor="Beklemishev, Lev D.
and Blass, Andreas
and Dershowitz, Nachum
and Finkbeiner, Bernd
and Schulte, Wolfram",
title="Horn Clause Solvers for Program Verification",
bookTitle="Fields of Logic and Computation II: Essays Dedicated to Yuri Gurevich on the Occasion of His 75th Birthday",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="24--51",
abstract="Automatic program verification and symbolic model checking tools interface with theorem proving technologies that check satisfiability of formulas. A theme pursued in the past years by the authors of this paper has been to encode symbolic model problems directly as Horn clauses and develop dedicated solvers for Horn clauses. Our solvers are called Duality, HSF, SeaHorn, and {\$}{\$}{\backslash}mu {\{}Z{\}}{\$}{\$}and we have devoted considerable attention in recent papers to algorithms for solving Horn clauses. This paper complements these strides as we summarize main useful properties of Horn clauses, illustrate encodings of procedural program verification into Horn clauses and then highlight a number of useful simplification strategies at the level of Horn clauses. Solving Horn clauses amounts to establishing Existential positive Fixed-point Logic formulas, a perspective that was promoted by Blass and Gurevich.",
isbn="978-3-319-23534-9",
doi="10.1007/978-3-319-23534-9_2",
url="https://doi.org/10.1007/978-3-319-23534-9_2"
}

@inproceedings{hsf,
author = {Grebenshchikov, Sergey and Lopes, Nuno P. and Popeea, Corneliu and Rybalchenko, Andrey},
title = {Synthesizing software verifiers from proof rules},
year = {2012},
isbn = {9781450312059},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2254064.2254112},
doi = {10.1145/2254064.2254112},
abstract = {Automatically generated tools can significantly improve programmer productivity. For example, parsers and dataflow analyzers can be automatically generated from declarative specifications in the form of grammars, which tremendously simplifies the task of implementing a compiler. In this paper, we present a method for the automatic synthesis of software verification tools. Our synthesis procedure takes as input a description of the employed proof rule, e.g., program safety checking via inductive invariants, and produces a tool that automatically discovers the auxiliary assertions required by the proof rule, e.g., inductive loop invariants and procedure summaries. We rely on a (standard) representation of proof rules using recursive equations over the auxiliary assertions. The discovery of auxiliary assertions, i.e., solving the equations, is based on an iterative process that extrapolates solutions obtained for finitary unrollings of equations. We show how our method synthesizes automatic safety and liveness verifiers for programs with procedures, multi-threaded programs, and functional programs. Our experimental comparison of the resulting verifiers with existing state-of-the-art verification tools confirms the practicality of the approach.},
booktitle = {Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {405–416},
numpages = {12},
keywords = {proof rules, software model checking, software verification, verification tool synthesis},
location = {Beijing, China},
series = {PLDI '12}
}

@InProceedings{seahorn,
author="Gurfinkel, Arie
and Kahsai, Temesghen
and Komuravelli, Anvesh
and Navas, Jorge A.",
editor="Kroening, Daniel
and P{\u{a}}s{\u{a}}reanu, Corina S.",
title="The SeaHorn Verification Framework",
booktitle="Computer Aided Verification",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="343--361",
abstract="In this paper, we present SeaHorn, a software verification framework. The key distinguishing feature of SeaHorn is its modular design that separates the concerns of the syntax of the programming language, its operational semantics, and the verification semantics. SeaHorn encompasses several novelties: it (a) encodes verification conditions using an efficient yet precise inter-procedural technique, (b) provides flexibility in the verification semantics to allow different levels of precision, (c) leverages the state-of-the-art in software model checking and abstract interpretation for verification, and (d) uses Horn-clauses as an intermediate language to represent verification conditions which simplifies interfacing with multiple verification tools based on Horn-clauses. SeaHorn provides users with a powerful verification tool and researchers with an extensible and customizable framework for experimenting with new software verification techniques. The effectiveness and scalability of SeaHorn are demonstrated by an extensive experimental evaluation using benchmarks from SV-COMP 2015 and real avionics code.",
isbn="978-3-319-21690-4"
}

@article{biere2002liveness,
title = {Liveness Checking as Safety Checking},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {66},
number = {2},
pages = {160-177},
year = {2002},
note = {FMICS'02, 7th International ERCIM Workshop in Formal Methods for Industrial Critical Systems (ICALP 2002 Satellite Workshop)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/S1571-0661(04)80410-9},
url = {https://www.sciencedirect.com/science/article/pii/S1571066104804109},
author = {Armin Biere and Cyrille Artho and Viktor Schuppan},
abstract = {Temporal logic is widely used for specifying hardware and software systems. Typically two types of properties are distinguished, safety and liveness properties. While safety can easily be checked by reachability analysis, and many efficient checkers for safety properties exist, more sophisticated algorithms have always been considered to be necessary for checking liveness. In this paper we describe an efficient translation of liveness checking problems into safety checking problems. A counter example is detected by saving a previously visited state in an additional state recording component and checking a loop closing condition. The approach handles fairness and thus extends to full LTL.}
}

@article{padon2017liveness,
author = {Padon, Oded and Hoenicke, Jochen and Losa, Giuliano and Podelski, Andreas and Sagiv, Mooly and Shoham, Sharon},
title = {Reducing liveness to safety in first-order logic},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158114},
doi = {10.1145/3158114},
abstract = {We develop a new technique for verifying temporal properties of infinite-state (distributed) systems. The main idea is to reduce the temporal verification problem to the problem of verifying the safety of infinite-state systems expressed in first-order logic. This allows to leverage existing techniques for safety verification to verify temporal properties of interesting distributed protocols, including some that have not been mechanically verified before. We model infinite-state systems using first-order logic, and use first-order temporal logic (FO-LTL) to specify temporal properties. This general formalism allows to naturally model distributed systems, while supporting both unbounded-parallelism (where the system is allowed to dynamically create processes), and infinite-state per process.  The traditional approach for verifying temporal properties of infinite-state systems employs well-founded relations (e.g. using linear arithmetic ranking functions). In contrast, our approach is based the idea of fair cycle detection. In finite-state systems, temporal verification can always be reduced to fair cycle detection (a system contains a fair cycle if it revisits a state after satisfying all fairness constraints). However, with both infinitely many states and infinitely many fairness constraints, a straightforward reduction to fair cycle detection is unsound. To regain soundness, we augment the infinite-state transition system by a dynamically computed finite set, that exploits the locality of transitions. This set lets us define a form of fair cycle detection that is sound in the presence of both infinitely many states, and infinitely many fairness constraints. Our approach allows a new style of temporal verification that does not explicitly involve ranking functions. This fits well with pure first-order verification which does not explicitly reason about numerical values. In particular, it can be used with effectively propositional first-order logic (EPR), in which case checking verification conditions is decidable. We applied our technique to verify temporal properties of several interesting protocols. To the best of our knowledge, we have obtained the first mechanized liveness proof for both TLB Shootdown, and Stoppable Paxos.},
journal = {Proc. ACM Program. Lang.},
month = dec,
articleno = {26},
numpages = {33},
keywords = {first-order temporal logic, Liveness-to-safety reduction}
}

@misc{mathieu_talk,
author={Fehr, Mathieu and Fan, Yuyou},
title={{Defining MLIR Semantics with an SMT Dialect}},
howpublished="\url{https://www.youtube.com/watch?v=gZdHrve9p40}"
}

@inproceedings{bogor,
author = {Robby and Dwyer, Matthew B. and Hatcliff, John},
title = {Bogor: an extensible and highly-modular software model checking framework},
year = {2003},
isbn = {1581137435},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/940071.940107},
doi = {10.1145/940071.940107},
abstract = {Model checking is emerging as a popular technology for reasoning about behavioral properties of a wide variety of software artifacts including: requirements models, architectural descriptions, designs, implementations, and process models. The complexity of model checking is well-known, yet cost-effective analyses have been achieved by exploiting, for example, naturally occurring abstractions and semantic properties of a target software artifact. semantic properties of target software artifacts. Adapting a model checking tool to exploit this kind of domain knowledge often requires in-depth knowledge of the tool's implementation.We believe that with appropriate tool support, domain experts will be able to develop efficient model checking-based analyses for a variety of software-related models. To explore this hypothesis, we have developed Bogor, a model checking framework with an extensible input language for defining domain-specific constructs and a modular interface design to ease the optimization of domain-specific state-space encodings, reductions and search algorithms. We present the pattern-oriented design of Bogor and discuss our experiences adapting it to efficiently model check Java programs and event-driven component-based designs.},
booktitle = {Proceedings of the 9th European Software Engineering Conference Held Jointly with 11th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
pages = {267–276},
numpages = {10},
keywords = {modular, model checker, extensible, domain-specific},
location = {Helsinki, Finland},
series = {ESEC/FSE-11}
}

@inproceedings{cascading_verification,
author = {Zervoudakis, Fokion and Rosenblum, David S. and Elbaum, Sebastian and Finkelstein, Anthony},
title = {Cascading verification: an integrated method for domain-specific model checking},
year = {2013},
isbn = {9781450322379},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491411.2491454},
doi = {10.1145/2491411.2491454},
abstract = {Model checking is an established method for verifying behavioral properties of system models. But model checkers tend to support low-level modeling languages that require intricate models to represent even the simplest systems. Modeling complexity arises in part from the need to encode domain knowledge at relatively low levels of abstraction.  In this paper, we demonstrate that formalized domain knowledge can be reused to raise the abstraction level of model and property specifications, and hence the effectiveness of model checking. We describe a novel method for domain-specific model checking called cascading verification that uses composite reasoning over high-level system specifications and formalized domain knowledge to synthesize both low-level system models and their behavioral properties for verification. In particular, model builders use a high-level domain-specific language (DSL) based on YAML to express system specifications that can be verified with probabilistic model checking. Domain knowledge is encoded in the Web Ontology Language (OWL), the Semantic Web Rule Language (SWRL) and Prolog, which are used in combination to overcome their individual limitations. A compiler then synthesizes models and properties for verification by the probabilistic model checker PRISM. We illustrate cascading verification for the domain of uninhabited aerial vehicles (UAVs), for which we have constructed a prototype implementation. An evaluation of this prototype reveals nontrivial reductions in the size and complexity of input specifications compared to the artifacts synthesized for PRISM.},
booktitle = {Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering},
pages = {400–410},
numpages = {11},
keywords = {Composite reasoning, OWL, PRISM, Prolog, SWRL, UAVs, domain model, model checking},
location = {Saint Petersburg, Russia},
series = {ESEC/FSE 2013}
}

@article{cytron1991efficiently,
author = {Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K. and Wegman, Mark N. and Zadeck, F. Kenneth},
title = {Efficiently computing static single assignment form and the control dependence graph},
year = {1991},
issue_date = {Oct. 1991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {13},
number = {4},
issn = {0164-0925},
url = {https://doi.org/10.1145/115372.115320},
doi = {10.1145/115372.115320},
journal = {ACM Trans. Program. Lang. Syst.},
month = oct,
pages = {451–490},
numpages = {40},
keywords = {control dependence, control flow graph, def-use chain, dominator, optimizing compilers}
}

@article{sat_quine,
author = {W. V. Quine},
title = {The Problem of Simplifying Truth Functions},
journal = {The American Mathematical Monthly},
volume = {59},
number = {8},
pages = {521--531},
year = {1952},
publisher = {Taylor \& Francis},
doi = {10.1080/00029890.1952.11988183},
URL = {https://doi.org/10.1080/00029890.1952.11988183},
eprint = {https://doi.org/10.1080/00029890.1952.11988183}

}

@incollection{barrett2021satisfiability,
title={Satisfiability modulo theories},
author={Barrett, Clark and Sebastiani, Roberto and Seshia, Sanjit A and Tinelli, Cesare},
booktitle={Handbook of satisfiability},
pages={1267--1329},
year={2021},
publisher={IOS Press}
}

@article{cong2022hls,
author = {Cong, Jason and Lau, Jason and Liu, Gai and Neuendorffer, Stephen and Pan, Peichen and Vissers, Kees and Zhang, Zhiru},
title = {FPGA HLS Today: Successes, Challenges, and Opportunities},
year = {2022},
issue_date = {December 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {15},
number = {4},
issn = {1936-7406},
url = {https://doi.org/10.1145/3530775},
doi = {10.1145/3530775},
abstract = {The year 2011 marked an important transition for FPGA high-level synthesis (HLS), as it went from prototyping to deployment. A decade later, in this article, we assess the progress of the deployment of HLS technology and highlight the successes in several application domains, including deep learning, video transcoding, graph processing, and genome sequencing. We also discuss the challenges faced by today’s HLS technology and the opportunities for further research and development, especially in the areas of achieving high clock frequency, coping with complex pragmas and system integration, legacy code transformation, building on open source HLS infrastructures, supporting domain-specific languages, and standardization. It is our hope that this article will inspire more research on FPGA HLS and bring it to a new height.},
journal = {ACM Trans. Reconfigurable Technol. Syst.},
month = aug,
articleno = {51},
numpages = {42},
keywords = {High-level synthesis, design automation, design tools, electronic design automation, FPGA architecture, FPGA acceleration, customizable computing, hardware compiler, hardware description, reconfigurable applications}
}

@article{sat_review,
author = {Alouneh, Sahel and Abed, Sa’ed and Al Shayeji, Mohammad H. and Mesleh, Raed},
title = {A comprehensive study and analysis on SAT-solvers: advances, usages and achievements},
year = {2019},
issue_date = {Dec 2019},
publisher = {Kluwer Academic Publishers},
address = {USA},
volume = {52},
number = {4},
issn = {0269-2821},
url = {https://doi.org/10.1007/s10462-018-9628-0},
doi = {10.1007/s10462-018-9628-0},
abstract = {Boolean satisfiability (SAT) has been studied for the last twenty years. Advances have been made allowing SAT solvers to be used in many applications including formal verification of digital designs. However, performance and capacity of SAT solvers are still limited. From the practical side, many of the existing applications based on SAT solvers use them as blackboxes in which the problem is translated into a monolithic conjunctive normal form instance and then throw it to the SAT solver with no interaction between the application and the SAT solver. This paper presents a comprehensive study and analysis of the latest developments in SAT-solver and new approaches that used in branching heuristics, Boolean constraint propagation and conflict analysis techniques during the last two decade. In addition, the paper provides the most effective techniques in using SAT solvers as verification techniques, mainly model checkers, to enhance the SAT solver performance, efficiency and productivity. Moreover, the paper presents the remarkable accomplishments and the main challenges facing SAT-solver techniques and contrasts between different techniques according to their efficiency, algorithms, usage and feasibility.},
journal = {Artif. Intell. Rev.},
month = dec,
pages = {2575–2601},
numpages = {27},
keywords = {SAT-solvers, CNF, EUF, Verification techniques, BMC, UMC}
}

@online{opentitan_good,
	title        = {Fabrication begins for production OpenTitan silicon},
	author       = {{Google Open Source Blog}},
	url          = {https://opensource.googleblog.com/2025/02/fabrication-begins-for-production-opentitan-silicon.html}
}

@inproceedings{koika,
author = {Bourgeat, Thomas and Pit-Claudel, Cl\'{e}ment and Chlipala, Adam and Arvind},
title = {The essence of Bluespec: a core language for rule-based hardware design},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3385965},
doi = {10.1145/3385412.3385965},
abstract = {The Bluespec hardware-description language presents a significantly higher-level view than hardware engineers are used to, exposing a simpler concurrency model that promotes formal proof, without compromising on performance of compiled circuits. Unfortunately, the cost model of Bluespec has been unclear, with performance details depending on a mix of user hints and opaque static analysis of potential concurrency conflicts within a design. In this paper we present Koika, a derivative of Bluespec that preserves its desirable properties and yet gives direct control over the scheduling decisions that determine performance. Koika has a novel and deterministic operational semantics that uses dynamic analysis to avoid concurrency anomalies. Our implementation includes Coq definitions of syntax, semantics, key metatheorems, and a verified compiler to circuits. We argue that most of the extra circuitry required for dynamic analysis can be eliminated by compile-time BSV-style static analysis.},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {243–257},
numpages = {15},
keywords = {Compiler Correctness, Hardware Description Language, Semantics},
location = {London, UK},
series = {PLDI 2020}
}
